<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | 薛定谔see猫</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    <meta charset="UTF-8" version="1">
    <meta name="baidu-site-verification" content="code-E5pfjV93p5">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="Keywords" content="个人博客, 薛定谔see猫,程序员,java">
    
    <link rel="preload" href="/assets/css/0.styles.aea1a24b.css" as="style"><link rel="preload" href="/assets/js/app.0d070191.js" as="script"><link rel="preload" href="/assets/js/3.0bb47036.js" as="script"><link rel="preload" href="/assets/js/1.5a70b7c3.js" as="script"><link rel="preload" href="/assets/js/12.328fb578.js" as="script"><link rel="prefetch" href="/assets/js/10.e081399c.js"><link rel="prefetch" href="/assets/js/11.a98b73cd.js"><link rel="prefetch" href="/assets/js/13.79a98088.js"><link rel="prefetch" href="/assets/js/14.04af00ec.js"><link rel="prefetch" href="/assets/js/15.e5577404.js"><link rel="prefetch" href="/assets/js/16.d2861ade.js"><link rel="prefetch" href="/assets/js/17.1f1183c9.js"><link rel="prefetch" href="/assets/js/18.53328597.js"><link rel="prefetch" href="/assets/js/19.bd296c49.js"><link rel="prefetch" href="/assets/js/20.2f448ba1.js"><link rel="prefetch" href="/assets/js/21.6a6ca5b1.js"><link rel="prefetch" href="/assets/js/22.be3b8d18.js"><link rel="prefetch" href="/assets/js/23.514fd3b1.js"><link rel="prefetch" href="/assets/js/24.64d69f2c.js"><link rel="prefetch" href="/assets/js/4.d6e8508b.js"><link rel="prefetch" href="/assets/js/5.dbaaa577.js"><link rel="prefetch" href="/assets/js/6.4fe70386.js"><link rel="prefetch" href="/assets/js/7.3c24189a.js"><link rel="prefetch" href="/assets/js/8.f3b0efe0.js"><link rel="prefetch" href="/assets/js/9.a5a3cc1f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.aea1a24b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>薛定谔see猫</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc></p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>薛定谔see猫</span>
            
          <!---->
          2021
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/logo.jpg" alt="薛定谔see猫" class="logo"> <span class="site-name">薛定谔see猫</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/assets/img/logo.jpg" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    薛定谔see猫
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>13</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>17</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6><li class="social-item" data-v-828910c6><i class="iconfont reco-github" style="color:#3498db;" data-v-828910c6></i></li><li class="social-item" data-v-828910c6><i class="iconfont reco-bilibili" style="color:#fb9b5f;" data-v-828910c6></i></li></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>C++</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>薛定谔see猫</span>
            
          <!---->
          2021
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">C++</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>薛定谔see猫</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>2021/4/3</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>c++</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="基础语法"><a href="#基础语法" class="header-anchor">#</a> 基础语法</h2> <p>将包裹的代码块按照<code>c语言</code>的方式编译</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span><span class="token punctuation">{</span>
	<span class="token comment">// 代码块</span>
<span class="token punctuation">}</span>
</code></pre></div><p>防止重复引入</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">宏</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">宏 </span><span class="token comment">//宏的定义一般是__文件名_H</span></span>

<span class="token comment">//代码块</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre></div><p>第二种防止重复引入</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token comment">// 兼容性不好</span>
</code></pre></div><h3 id="内联函数"><a href="#内联函数" class="header-anchor">#</a> 内联函数</h3> <p>使用<code>inline</code>所修饰的函数声明或者实现,编译器会将内联函数直接转换为函数代码</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">//函数体</span>
<span class="token punctuation">}</span>
</code></pre></div><p>内联函数的执行不需要分配栈空间，执行了效率</p> <p>会增大代码的体积</p> <p>递归函数不会变成内联</p> <h3 id="const"><a href="#const" class="header-anchor">#</a> const</h3> <p><code>const</code>仅仅修饰其右边的值，被修饰的值为常量不可修改</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>age<span class="token punctuation">;</span>  <span class="token comment">// p1不是常量，*p1是常量</span>
<span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>age<span class="token punctuation">;</span>  <span class="token comment">// p2不是常量，*p3是常量</span>
<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>age<span class="token punctuation">;</span> <span class="token comment">//p3是常量，*p3不是</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p4 <span class="token operator">=</span> <span class="token operator">&amp;</span>age<span class="token punctuation">;</span> <span class="token comment">//p4,*p4都是常量</span>
<span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span> <span class="token keyword">const</span> p5 <span class="token operator">=</span> <span class="token operator">&amp;</span>age<span class="token punctuation">;</span> <span class="token comment">//p5,*p5都是常量</span>
</code></pre></div><h3 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h3> <p>相当于给变量起别名，对引用做计算就相当于对引用所指向的变量做计算</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//定义一个引用，</span>
</code></pre></div><p>指针的引用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>age<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>ref <span class="token operator">=</span> p<span class="token punctuation">;</span>
</code></pre></div><p>数组的引用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>ref1<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">;</span>

<span class="token comment">// 两种写法</span>
<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>ref2 <span class="token operator">=</span> arr<span class="token punctuation">;</span>
</code></pre></div><p>常引用：引用可以被<code>const</code>修饰，这样就无法通过引用修改数据了，可以称为常引用,常引用可以引用常量，也可以引用不同类型的数据，但是不同类型的变量相当于引用指向了一个临时变量</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>ref1 <span class="token operator">=</span> age<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>ref2 <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">&amp;</span>ref3 <span class="token operator">=</span> age<span class="token punctuation">;</span>
</code></pre></div><p>对于函数而言：如果形参为引用，则只能接受非const实参，而常引用可以接受任意的实参，常引用与非常引用函数可以构成函数重载</p> <p>引用定义时必须赋初值</p> <p>引用一旦定义不可修改其指向</p> <p>引用的本质就是指针，知识编译器削弱了它的功能，所以引用就是弱化了的指针</p> <h3 id="默认参数"><a href="#默认参数" class="header-anchor">#</a> 默认参数</h3> <p>c++允许函数的参数有默认值</p> <p>默认参数写在声明里，实现不必写</p> <h2 id="intel-x64汇编"><a href="#intel-x64汇编" class="header-anchor">#</a> intel x64汇编</h2> <h3 id="内联汇编"><a href="#内联汇编" class="header-anchor">#</a> 内联汇编</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code>__asm<span class="token punctuation">{</span>
	<span class="token punctuation">;</span>汇编代码
<span class="token punctuation">}</span>
</code></pre></div><h3 id="寄存器"><a href="#寄存器" class="header-anchor">#</a> 寄存器</h3> <p>64位通用寄存器：<code>RAX</code>、<code>RBX</code>、<code>RCX</code>、<code>RDX</code>，<code>R</code>开头的寄存器时64位的，占8个字节。<code>E</code>开头的是32位的占四个字节</p> <h3 id="汇编指令"><a href="#汇编指令" class="header-anchor">#</a> 汇编指令</h3> <p>将src的内容赋值给dest，类似于dest=src</p> <div class="language-assembly extra-class"><pre class="language-text"><code>mov dest, src
</code></pre></div><p>中括号<code>[]</code>里面放的都是内存地址</p> <div class="language-assembly extra-class"><pre class="language-text"><code>[地址值]
</code></pre></div><p><code>word</code>两个字节，<code>dword</code>是四个字节，<code>qword</code>是八字节</p> <div class="language-assembly extra-class"><pre class="language-text"><code>mov dword ptr [地址], 值
;将值放入指定地址的四个字节中
</code></pre></div><p>调用函数</p> <div class="language-assembly extra-class"><pre class="language-text"><code>call 函数地址
</code></pre></div><p>取地址</p> <div class="language-assembly extra-class"><pre class="language-text"><code>lea eax, [地址值]
</code></pre></div><p>函数返回</p> <div class="language-assembly extra-class"><pre class="language-text"><code>ret
</code></pre></div><p>异或</p> <div class="language-assembly extra-class"><pre class="language-text"><code>xor op1, op2
;将op1与op2异或的值赋值给op1
</code></pre></div><p>加法</p> <div class="language-assembly extra-class"><pre class="language-text"><code>add op1, op2
;op1=op1+op2
</code></pre></div><p>减法</p> <div class="language-assembly extra-class"><pre class="language-text"><code>sub op1, op2
</code></pre></div><p>自加</p> <div class="language-assembly extra-class"><pre class="language-text"><code>inc op
;op++
</code></pre></div><p>自减</p> <div class="language-assembly extra-class"><pre class="language-text"><code>dec op
;op--
</code></pre></div><p>跳转</p> <div class="language-assembly extra-class"><pre class="language-text"><code>jmp 内存地址
</code></pre></div><h2 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h2> <h3 id="内存空间的布局"><a href="#内存空间的布局" class="header-anchor">#</a> 内存空间的布局</h3> <p>每个应用都有自己独立的内存空间，其内存空间一般有以下几个区域</p> <ul><li>代码段(代码区)：用于存放代码</li> <li>数据段(全局区)：用于存放全局变量等</li> <li>栈空间：没调用一个函数就会给它分配一段连续的占空间,等函数调用完毕后自动回收这些栈空间</li> <li>堆空间：需要主动去申请和释放</li></ul> <h3 id="内存创建与销毁"><a href="#内存创建与销毁" class="header-anchor">#</a> 内存创建与销毁</h3> <p><code>malloc/free</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 申请</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 初始化 将每一个字节都设置为0</span>
<span class="token function">memset</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 释放</span>
<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>new/delete</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 申请</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">// int *p = new int(0); 初始化为0</span>
<span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 释放</span>
<span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">;</span>
</code></pre></div><h3 id="类"><a href="#类" class="header-anchor">#</a> 类</h3> <p>c++里可以通过<code>struct</code>、和<code>class</code>来定义类，<code>struct</code>的默认成员是<code>public</code>，而<code>class</code>默认是<code>private</code></p> <h3 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h3> <p>对象是类的实例</p> <p>对象的内存布局是连续的，默认的对象是放在栈空间</p> <h3 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h3> <p>成员变量私有化，提供公共的<code>getter</code>和<code>setter</code>给外界去访问成员变量</p> <h3 id="构造函数"><a href="#构造函数" class="header-anchor">#</a> 构造函数</h3> <p>构造函数也叫构造器，在对象创建的时候自动调用，一般用于完成对象的初始化工作</p> <p>构造函数的名字和类的名字相同，没有返回值可以有参数，可以重载</p> <p>一旦定义了构造函数，必须通过其中一个来初始化对象</p> <p><code>malloc</code>定义的对象不会调用构造函数</p> <p>在某些特定的情况下，编译器会为类生成空的无参的构造函数</p> <h3 id="成员变量的初始化"><a href="#成员变量的初始化" class="header-anchor">#</a> 成员变量的初始化</h3> <p>默认情况下(无构造函数)：全局区的成员变量初始化为0，栈空间不会初始化，堆空间带<code>()</code>的初始化</p> <p>如果自定义了构造函数，除了全局区都不会初始化</p> <h3 id="析构函数"><a href="#析构函数" class="header-anchor">#</a> 析构函数</h3> <p>析构函数在对象销毁之前调用，用于清理内存</p> <p>析构函数的名字为<code>~类名</code>，不能重载</p> <p><code>malloc</code>创建的对象不会调用析构函数</p> <p>构造函数与析构函数都需要为<code>public</code>才能被对象调用</p> <h3 id="命名空间"><a href="#命名空间" class="header-anchor">#</a> 命名空间</h3> <p>c++可以通过命名空间来防止变量，类等命名冲突的问题</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> 名字 <span class="token punctuation">{</span>
	<span class="token comment">// 代码块</span>
<span class="token punctuation">}</span>
</code></pre></div><p>命名空间有一个默认的命名空间，没有名字,所有的代码都嵌套在全局命名空间里面</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">::</span>
</code></pre></div><h3 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h3> <p>通过继承可以让子类拥有父类的成员变量和函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> 子类名 <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">public</span><span class="token punctuation">]</span> 父类名 <span class="token punctuation">{</span>
	
<span class="token punctuation">}</span>
</code></pre></div><p>继承默认为私有继承</p> <h3 id="成员访问权限"><a href="#成员访问权限" class="header-anchor">#</a> 成员访问权限</h3> <p><code>public</code>，成员为公共的成员，即可以任意访问</p> <p><code>private</code>成员为私有成员，即意味着只能在类中访问</p> <p><code>producted</code>类以及子类里可以访问该成员</p> <p>访问权限不影响内存布局</p> <h3 id="初始化列表"><a href="#初始化列表" class="header-anchor">#</a> 初始化列表</h3> <p>一种便捷的初始换成员变量的方式</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>构造函数<span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_age</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_height</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// 成员变量的初始化顺序只跟定义的顺序有关</span>
<span class="token punctuation">}</span>
</code></pre></div><p>只能用于构造函数中，声明和实现分离初始化列表放在实现里面</p> <p>对于构造函数的相互调用只能放在初始化列表中</p> <h3 id="父类构造函数"><a href="#父类构造函数" class="header-anchor">#</a> 父类构造函数</h3> <p>子类的构造函数默认回去调用父类的构造函数</p> <p>如果子类的构造函数显示地调用了父类的有参构造函数，就不会再去默认调用父类的无参构造函数</p> <p>如果父类没有构造函数，则不会调用父类的构造函数</p> <h3 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h3> <p>父类指针可以指向子类对象(通过public继承)但是只能访问父类的属性和方法，子类指针不可以指向父类对象</p> <p>同一操作作用域不同的对象，可以有不同的解释，产生不同的结果</p> <p>子类通过重写父类的虚(virtual)方法，来实现多态</p> <p>如果父类的函数(方法)为虚函数，则子类重写的函数也为虚函数</p> <p>虚函数的实现原理是虚表，这个虚表里面存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表，一个对象(如果有虚表)最前的4/8个字节存储的是虚表的地址</p> <p>在子类中可以调用父类的虚函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>类名<span class="token operator">::</span>函数名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>虚析构函数：如果存在父类指针指向子类对象的情况，应该将析构函数声明为虚函数，否则子类的析构函数不会被调用</p> <p>纯虚函数：没有函数体且初始化为0的虚函数，用来定义接口规范</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">virtual</span> 函数声明 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p>只要一个类中包含纯虚函数这个类就称为抽象类，抽象类不能创建对象</p> <p>如果父类是抽象类，子类没有完全重写纯虚函数，那么这个子类依然是抽象类</p> <h3 id="多继承"><a href="#多继承" class="header-anchor">#</a> 多继承</h3> <p>C++允许一个类可以有多个父类（不建议使用），内存布局跟继承的顺序有关</p> <p>如果子类继承的多个父类都有虚函数，那么子类对象就会产生对应的多张虚表</p> <p>如果成员变量或者方法有同名，默认访问对象本身的变量或方法，访问父类的变量或方法应使用其类名</p> <div class="language-c++ extra-class"><pre class="language-text"><code>对象名.父类名::成员
</code></pre></div><h3 id="虚继承"><a href="#虚继承" class="header-anchor">#</a> 虚继承</h3> <p>菱形继承：B、C继承A，D继承B、C会导致A被D重复继承</p> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><p>虚继承在<code>B</code>、<code>C</code>类继承时添加<code>virtual</code>关键字修饰，虚继承的后果是BC继承的为同一块<code>内存</code>里的东西</p> <p>B、C的内存布局</p> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><p>虚表指针指向的内存空间里</p> <ul><li>虚表指针与本类起始的偏移量(一般是0)</li> <li>虚基类第一个成员变量与本类起始的偏移量</li></ul> <p>D的内存布局</p> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><h3 id="静态成员"><a href="#静态成员" class="header-anchor">#</a> 静态成员</h3> <p>被<code>static</code>修饰的成员变量称为静态成员</p> <p>静态成员变量</p> <ul><li>存储在数据段(全局区，类似于全局变量)，整个程序运行过程中只有一份内存</li> <li>静态成员变量必须放在类的外面初始化，初始化不需要带<code>static</code></li></ul> <p>静态成员函数</p> <ul><li>静态成员函数内部没有<code>this</code></li> <li>静态成员函数不能用<code>virtual</code>修饰</li> <li>静态成员函数内部不能访问非静态成员变量/函数</li></ul> <p>静态成员也可以通过<code>类名::静态成员名</code>来访问</p> <p>如果继承的父类含有同名的静态成员则，它们属于不同的变量</p> <p>应用常见：单例模式，保证某个类只创建一个对象</p> <ul><li>（拷贝）构造函数私有化</li> <li>定义一个私有的<code>static</code>成员变量指向唯一的哪个单例对象</li> <li>提供一个公共的访问单例对象的方法</li> <li>重载赋值运算符私有化</li></ul> <h3 id="const成员"><a href="#const成员" class="header-anchor">#</a> const成员</h3> <p>只有静态函数成员不能被<code>const</code>修饰</p> <p><code>const</code>成员变量</p> <ul><li><code>const</code>成员变量必须在定义时或构造函数的初始化列表中初始化</li> <li><code>static</code>可以修饰<code>const</code></li></ul> <p><code>const</code>成员函数</p> <ul><li><p><code>const</code>关键字写在参数列表后面，函数的声明和实现都必须加<code>const</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>
	<span class="token comment">// 函数体</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>函数内部不能修改非静态成员变量</p></li> <li><p>函数内部只能调用<code>cosnt</code>、<code>static</code>成员函数</p></li> <li><p><code>const</code>成员函数可以和非<code>const</code>构成重载，</p></li> <li><p>非<code>const</code>对象优先调用非<code>const</code>函数</p></li> <li><p><code>const</code>对象只能调用<code>const</code>、<code>static</code>函数</p></li></ul> <h3 id="引用类型成员"><a href="#引用类型成员" class="header-anchor">#</a> 引用类型成员</h3> <p>引用类型成员变量必须初始化，可以在声明的时候初始化，也可以通过初始化列表初始化</p> <h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="header-anchor">#</a> 拷贝构造函数</h3> <p>拷贝构造函数的语法是固定的，接受一个<code>const</code>引用的对象</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>类名<span class="token punctuation">(</span><span class="token keyword">const</span> 类名 <span class="token operator">&amp;</span>变量名<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// 函数体</span>
<span class="token punctuation">}</span>
</code></pre></div><p>利用已存在的对象创建一个新对象时，就会调用新对象的拷贝构造函数进行初始化</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>类名 要创建的对象<span class="token punctuation">(</span>已经存在的对象<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>默认情况下(没有定义拷贝构造函数)</p> <p>会将已存在的对象的成员变量一一赋值给要创建的对象的成员变量</p> <p>默认的拷贝为浅拷贝</p> <h3 id="对象型参数和返回值"><a href="#对象型参数和返回值" class="header-anchor">#</a> 对象型参数和返回值</h3> <p>使用对象类型作为函数的参数或者返回值，可能会产生一些不必要的中间对象</p> <p>使用对象作为函数参数尽量使用引用</p> <h4 id="匿名对象"><a href="#匿名对象" class="header-anchor">#</a> 匿名对象</h4> <p>没有变量名，创建之后即销毁</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>类名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>匿名对象的生命周期仅限于当前行</p> <p>如果是匿名对象作为函数参数，则仅会调用一次构造函数</p> <p>c++存在隐式构造，即可以将一个常量赋值给一个对象，默认情况下（必须有单参数的构造函数或者其他参数有默认值）这个常量会隐式生成一个匿名对象将常量值赋值给这个隐式对象，可以通过<code>explicit</code>修饰构造函数来禁止隐式构造</p> <h3 id="编译器自动生成构造函数"><a href="#编译器自动生成构造函数" class="header-anchor">#</a> 编译器自动生成构造函数</h3> <p>编译器在某些特定的情况下会自动生成构造函数</p> <ul><li>成员变量在声明的同时进行了初始化</li> <li>有定义虚函数</li> <li>虚继承了其他类</li> <li>包含了对象类型的成员，且这个成员有构造函数</li> <li>父类有有构造函数</li></ul> <p>对象创建后，需要做一些额外的操作(内存操作，函数调用)，编译器会自动生成无参的构造函数</p> <h3 id="友元"><a href="#友元" class="header-anchor">#</a> 友元</h3> <p>假设有类<code>A</code>、<code>B</code>和函数<code>func</code></p> <p>友元函数：</p> <p>将一个函数在类中声明为友元函数即可在函数内部访问对象的私有成员，通过<code>friend</code>关键字修饰，友元函数不能是成员函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 在类A中声明</span>
<span class="token keyword">friend</span> 函数返回值 <span class="token function">func</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a1<span class="token punctuation">,</span> A<span class="token operator">&amp;</span> a2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将函数func声明为A的友元函数</span>
</code></pre></div><p>友元类：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 在类A中声明</span>
<span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">;</span>

<span class="token comment">// 将类B声明为类A的友元类</span>
</code></pre></div><h3 id="内部类"><a href="#内部类" class="header-anchor">#</a> 内部类</h3> <p>将一个类定义到另一个类的内部称为内部类(嵌套类)</p> <p>内部类可以设置访问权限，如果为<code>public</code>需要通过外层类的名字进行访问</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>外部类<span class="token operator">::</span>内部类 对象名<span class="token punctuation">;</span>
</code></pre></div><p>内部类可以访问外部类的成员(包括静态成员)，外部类不能访问内部类的私有成员</p> <p>内部类不影响外部类的内存布局</p> <p>内部类可以在外部类中声明，实现放在外面</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
	<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">B</span></span> <span class="token punctuation">{</span>
	
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="局部类"><a href="#局部类" class="header-anchor">#</a> 局部类</h3> <p>定义在函数内部的类</p> <p>局部类声明和实现必须放在内部</p> <p>局部类不允许定义静态成员变量</p> <p>局部类不能访问该函数的变量<code>static</code>变量除外</p> <p>局部类不影响函数的内存布局</p> <h3 id="运算符重载"><a href="#运算符重载" class="header-anchor">#</a> 运算符重载</h3> <p>可以为运算符增加一些新的功能</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> 返回值 <span class="token keyword">operator</span> 重载的运算符<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span>	<span class="token keyword">const</span><span class="token punctuation">{</span>
	<span class="token comment">// 参数列表最好加上const</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了参数列表能够接受常量对象，所以参数列表里的参数应声明为<code>const</code></p> <p>运算符重载(若有返回值)最好返回一个<code>const</code>变量(对象)，因为运算符重载过后运算的结果是一个临时的变量，不应该能被赋值</p> <p>又因为<code>const</code>对象只能调用<code>const</code>函数所以函数也应该声明为<code>const</code></p> <p>对于<code>++</code>运算符有<code>++p</code>和<code>p++</code>之分</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> 类 <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// p++, 参数列表必须是int</span>
    <span class="token keyword">return</span> 类<span class="token punctuation">(</span>成员变量<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
类<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// ++p，这种方式应该可以被赋值</span>
    <span class="token comment">// 成员变量++</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span>
<span class="token punctuation">}</span>
</code></pre></div><p>左移和右移只能重载为全局函数，然后在类中声明友元</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>ostream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>cout<span class="token punctuation">,</span><span class="token keyword">const</span> 对象<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// cout</span>
	<span class="token keyword">return</span> cout<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
istream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>cout<span class="token punctuation">,</span>对象<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// cin</span>
	<span class="token keyword">return</span> cin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于有继承关系的的重载赋值运算符，应在子类里调用父类的赋值运算符</p> <p>仿函数即重载<code>()</code>该函数类似于普通的全局函数但，这种函数可以访问成员变量</p> <p>不可被重载的运算符：<code>.</code>、<code>::</code>、<code>?:</code>、<code>sizeof</code></p> <p>只能重载为成员函数：<code>=</code>、<code>[]</code>、<code>()</code>、<code>-&gt;</code></p> <h2 id="模板"><a href="#模板" class="header-anchor">#</a> 模板</h2> <p>泛型：是一种将类型参数化以达到代码复用的技术，C++中使用模板来实现泛型</p> <p>模板语法</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token operator">/</span>calss T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token operator">/</span>calss A<span class="token operator">&gt;</span>
函数声明 <span class="token punctuation">{</span>
	<span class="token comment">// 函数体</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
函数名字<span class="token operator">&lt;</span>类型名<span class="token operator">&gt;</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>模板的声明和实现放在<code>.h</code>、<code>.cpp</code>则会编译出错</p> <p>一般模板的声明和实现都会放在一个<code>.hpp</code>文件中</p> <p>对于声明和实现分离的模板类的实现需要添加修饰</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T 类名<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span>函数名<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// 函数体</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于分离的友元函数需要额外的<code>&lt;&gt;</code>修饰</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>返回值 函数名<span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// 函数体</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="类型转换"><a href="#类型转换" class="header-anchor">#</a> 类型转换</h2> <h3 id="c语言强制转换"><a href="#c语言强制转换" class="header-anchor">#</a> c语言强制转换</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token punctuation">(</span>type<span class="token punctuation">)</span>表达式<span class="token punctuation">;</span>

<span class="token function">type</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="c-强制转化"><a href="#c-强制转化" class="header-anchor">#</a> C++强制转化</h3> <p><code>static_cast</code>：没有运行时检测，不能交叉转换(两个没有任何联系的变量/对象之间的转换)，常用于基本数据类型的转换，非<code>const</code>、转换为<code>const</code></p> <p><code>dynamic_cast</code>：一般用于多态的转换，有运行时安全检测，如果不安全会将指针置空</p> <p><code>reinterpret_cast</code>：属于比较壁层的强制转换，没有任何类型检查和格式转换，仅仅是简单的二进制数据拷贝，它的类型需要有时引用，可以交叉转换，也可以将指针与变量之间进行转换</p> <p><code>const_cast</code>：将<code>const</code>转换为非<code>const</code></p> <p>格式</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>xx_cast<span class="token operator">&lt;</span>类型<span class="token operator">&gt;</span>表达式<span class="token punctuation">;</span>
</code></pre></div><h2 id="c-11特性"><a href="#c-11特性" class="header-anchor">#</a> C++11特性</h2> <p><code>auto</code>：可以从初始化表达式中推断出变量的类型，大大简化编程工作</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">// 自动推断a为整型</span>
</code></pre></div><p><code>decltype</code>：获取变量的类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
</code></pre></div><p><code>nullptr</code>：空指针,解决了NULL二义性的问题</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
</code></pre></div><p>快速遍历</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> item <span class="token operator">:</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> item <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Lambda</code>表达式，可以定义在函数内部的函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 定义 可以使用auto</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Hello World&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 调用</span>
<span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 立即执行</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Hello World&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 带返回值和参数的表达式，返回值可省略</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>捕获</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 捕获外部的值</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token comment">// 可以传引用，进行地址捕获</span>
<span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 自动捕获，值捕获， 将=换成&amp;地址捕获</span>
<span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>改变捕获的变量的值</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 采用地址捕获</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>a<span class="token punctuation">]</span><span class="token punctuation">{</span>
	a<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 采用mutable,不会影响表达式外部的值</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span><span class="token punctuation">{</span>
    a<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="异常"><a href="#异常" class="header-anchor">#</a> 异常</h2> <h3 id="语法"><a href="#语法" class="header-anchor">#</a> 语法</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
	<span class="token comment">// 可能会抛出异常的代码</span>
    <span class="token comment">// 抛出异常的代码下面抛出异常之后不会执行</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// (异常类型 变量名)异常类型,异常类型不一样catch可以有多个， ...代表所有异常</span>
	<span class="token comment">// 捕捉到异常需要做的事情</span>
<span class="token punctuation">}</span>
</code></pre></div><p>主动抛出异常</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">throw</span> <span class="token string">&quot;主动抛出&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 需要try catch 捕捉</span>
</code></pre></div><p><code>throw</code>异常之后会在当前函数中查找匹配的<code>catch</code>，找不到就终止当前函数代码，去上一层函数中查找，如果到<code>main</code>函数中依然没有匹配的<code>catch</code>程序会被终止</p> <p>捕捉异常的类型匹配是严谨的，不存在隐式转换</p> <h3 id="异常抛出声明"><a href="#异常抛出声明" class="header-anchor">#</a> 异常抛出声明</h3> <p>为了增强可读性和方便团队协作，如果函数内部可能会抛出异常，建议函数声明异常类型</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 可能会抛出任意类型的异常</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>

<span class="token comment">// 不会抛出异常</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>

<span class="token comment">// 抛出指定类型的异常</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>异常类型<span class="token punctuation">)</span><span class="token punctuation">{</span>
	
<span class="token punctuation">}</span>
</code></pre></div><h3 id="自定义异常类型"><a href="#自定义异常类型" class="header-anchor">#</a> 自定义异常类型</h3> <p>定义所有异常的基类</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 所有异常均继承自基类</span>
<span class="token keyword">class</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
	<span class="token comment">// 定义一些纯虚函数来规范异常，纯虚函数一般为const</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>定义异常</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> 异常函数名Exception <span class="token operator">:</span> <span class="token keyword">public</span> Exception<span class="token punctuation">{</span>
	<span class="token comment">// 重写父类的虚函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="标准异常"><a href="#标准异常" class="header-anchor">#</a> 标准异常</h3> <table><thead><tr><th>异常</th> <th>描述</th></tr></thead> <tbody><tr><td>std::exception</td> <td>该异常是所有标准C++异常的父类</td></tr> <tr><td>std::bad_alloc</td> <td>该异常可以通过new抛出</td></tr> <tr><td>std::bad_cast</td> <td>该异常可以通过dynamic_cast抛出</td></tr> <tr><td>std::bad_exception</td> <td>这在处理C++程序中无法预期的异常时</td></tr></tbody></table> <p>等等。。，C++标准里定义了许多异常</p> <h2 id="智能指针"><a href="#智能指针" class="header-anchor">#</a> 智能指针</h2> <p>智能指针指向内存的生命周期跟随指针变量的生命周期，不需要手动销毁，智能指针不要指向栈空间的对象，否则会多次调用析构函数</p> <h3 id="auto-ptr"><a href="#auto-ptr" class="header-anchor">#</a> auto_ptr</h3> <p>不能用于数组，不推荐使用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>auto_ptr<span class="token operator">&lt;</span>类型<span class="token operator">&gt;</span> 变量名<span class="token punctuation">(</span><span class="token keyword">new</span> 类型<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="shared-ptr"><a href="#shared-ptr" class="header-anchor">#</a> shared_ptr</h3> <p>支持数组,且多个<code>shared_ptr</code>可以指向同一个指针对象</p> <p>一个<code>shared_ptr</code>会对一个对象产生强引用，每个对象都有与之对应的强引用技术，记录着当前多少个<code>shared_ptr</code>被墙引用着，可以通过<code>shared_ptr</code>的<code>use_count</code>函数获得强引用计数</p> <p>当有一个新的<code>shared_ptr</code>指向对象时，对象的强引用计数就会加1，销毁则减一</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>shared_ptr<span class="token operator">&lt;</span>类型<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> 变量名<span class="token punctuation">(</span><span class="token keyword">new</span> 类型<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>对于<code>shared_ptr</code>指针而言有循环引用的风险，而<code>weak_ptr</code>弱引用智能指针能解决</p> <h3 id="unique-ptr"><a href="#unique-ptr" class="header-anchor">#</a> unique_ptr</h3> <p>也会对一个对象产生强引用，它可以确保同一时间只有一个指针指向对象</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>unique_ptr<span class="token operator">&lt;</span>类型<span class="token operator">&gt;</span> 变量名<span class="token punctuation">(</span><span class="token keyword">new</span> 类型<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>特别情况下可以使用<code>std::move()</code>转移智能指针,原指针被销毁</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>指针<span class="token number">1</span> <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>指针<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后修改时间: </span> <span class="time">3 天前</span></div></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/c++/c++.html#基础语法" class="sidebar-link reco-side-基础语法" data-v-70334359>基础语法</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#内联函数" class="sidebar-link reco-side-内联函数" data-v-70334359>内联函数</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#const" class="sidebar-link reco-side-const" data-v-70334359>const</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#引用" class="sidebar-link reco-side-引用" data-v-70334359>引用</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#默认参数" class="sidebar-link reco-side-默认参数" data-v-70334359>默认参数</a></li><li class="level-2" data-v-70334359><a href="/c++/c++.html#intel-x64汇编" class="sidebar-link reco-side-intel-x64汇编" data-v-70334359>intel x64汇编</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#内联汇编" class="sidebar-link reco-side-内联汇编" data-v-70334359>内联汇编</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#寄存器" class="sidebar-link reco-side-寄存器" data-v-70334359>寄存器</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#汇编指令" class="sidebar-link reco-side-汇编指令" data-v-70334359>汇编指令</a></li><li class="level-2" data-v-70334359><a href="/c++/c++.html#面向对象" class="sidebar-link reco-side-面向对象" data-v-70334359>面向对象</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#内存空间的布局" class="sidebar-link reco-side-内存空间的布局" data-v-70334359>内存空间的布局</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#内存创建与销毁" class="sidebar-link reco-side-内存创建与销毁" data-v-70334359>内存创建与销毁</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#类" class="sidebar-link reco-side-类" data-v-70334359>类</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#对象" class="sidebar-link reco-side-对象" data-v-70334359>对象</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#封装" class="sidebar-link reco-side-封装" data-v-70334359>封装</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#构造函数" class="sidebar-link reco-side-构造函数" data-v-70334359>构造函数</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#成员变量的初始化" class="sidebar-link reco-side-成员变量的初始化" data-v-70334359>成员变量的初始化</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#析构函数" class="sidebar-link reco-side-析构函数" data-v-70334359>析构函数</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#命名空间" class="sidebar-link reco-side-命名空间" data-v-70334359>命名空间</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#继承" class="sidebar-link reco-side-继承" data-v-70334359>继承</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#成员访问权限" class="sidebar-link reco-side-成员访问权限" data-v-70334359>成员访问权限</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#初始化列表" class="sidebar-link reco-side-初始化列表" data-v-70334359>初始化列表</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#父类构造函数" class="sidebar-link reco-side-父类构造函数" data-v-70334359>父类构造函数</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#多态" class="sidebar-link reco-side-多态" data-v-70334359>多态</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#多继承" class="sidebar-link reco-side-多继承" data-v-70334359>多继承</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#虚继承" class="sidebar-link reco-side-虚继承" data-v-70334359>虚继承</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#静态成员" class="sidebar-link reco-side-静态成员" data-v-70334359>静态成员</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#const成员" class="sidebar-link reco-side-const成员" data-v-70334359>const成员</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#引用类型成员" class="sidebar-link reco-side-引用类型成员" data-v-70334359>引用类型成员</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#拷贝构造函数" class="sidebar-link reco-side-拷贝构造函数" data-v-70334359>拷贝构造函数</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#对象型参数和返回值" class="sidebar-link reco-side-对象型参数和返回值" data-v-70334359>对象型参数和返回值</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#编译器自动生成构造函数" class="sidebar-link reco-side-编译器自动生成构造函数" data-v-70334359>编译器自动生成构造函数</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#友元" class="sidebar-link reco-side-友元" data-v-70334359>友元</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#内部类" class="sidebar-link reco-side-内部类" data-v-70334359>内部类</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#局部类" class="sidebar-link reco-side-局部类" data-v-70334359>局部类</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#运算符重载" class="sidebar-link reco-side-运算符重载" data-v-70334359>运算符重载</a></li><li class="level-2" data-v-70334359><a href="/c++/c++.html#模板" class="sidebar-link reco-side-模板" data-v-70334359>模板</a></li><li class="level-2" data-v-70334359><a href="/c++/c++.html#类型转换" class="sidebar-link reco-side-类型转换" data-v-70334359>类型转换</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#c语言强制转换" class="sidebar-link reco-side-c语言强制转换" data-v-70334359>c语言强制转换</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#c-强制转化" class="sidebar-link reco-side-c-强制转化" data-v-70334359>C++强制转化</a></li><li class="level-2" data-v-70334359><a href="/c++/c++.html#c-11特性" class="sidebar-link reco-side-c-11特性" data-v-70334359>C++11特性</a></li><li class="level-2" data-v-70334359><a href="/c++/c++.html#异常" class="sidebar-link reco-side-异常" data-v-70334359>异常</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#语法" class="sidebar-link reco-side-语法" data-v-70334359>语法</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#异常抛出声明" class="sidebar-link reco-side-异常抛出声明" data-v-70334359>异常抛出声明</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#自定义异常类型" class="sidebar-link reco-side-自定义异常类型" data-v-70334359>自定义异常类型</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#标准异常" class="sidebar-link reco-side-标准异常" data-v-70334359>标准异常</a></li><li class="level-2" data-v-70334359><a href="/c++/c++.html#智能指针" class="sidebar-link reco-side-智能指针" data-v-70334359>智能指针</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#auto-ptr" class="sidebar-link reco-side-auto-ptr" data-v-70334359>auto_ptr</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#shared-ptr" class="sidebar-link reco-side-shared-ptr" data-v-70334359>shared_ptr</a></li><li class="level-3" data-v-70334359><a href="/c++/c++.html#unique-ptr" class="sidebar-link reco-side-unique-ptr" data-v-70334359>unique_ptr</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;left:50px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div></div></div>
    <script src="/assets/js/app.0d070191.js" defer></script><script src="/assets/js/3.0bb47036.js" defer></script><script src="/assets/js/1.5a70b7c3.js" defer></script><script src="/assets/js/12.328fb578.js" defer></script>
  </body>
</html>
